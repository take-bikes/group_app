<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@200;300;400&display=swap" rel="stylesheet">
<style>
    /* loading.html å°‚ç”¨ã®ã‚¹ã‚¿ã‚¤ãƒ« */
    #loadingOverlay {
        position: fixed;
        inset: 0;
        z-index: 9999;
        display: none;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        overflow: hidden;
        background: linear-gradient(to bottom, #f8fbff, #e3eeff);
        font-family: 'Montserrat', sans-serif;
        cursor: default;
    }

    #loadingOverlay.visible {
        display: flex;
    }

    #loadingCanvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1;
    }

    .loading-content-wrapper {
        position: relative;
        z-index: 2;
        text-align: center;
        color: #1a2a3a;
        pointer-events: none;
        user-select: none;
        margin-top: -5%;
    }

    .loading-content-wrapper h1 {
        font-size: 3.5rem;
        letter-spacing: 0.3em;
        font-weight: 200;
        margin-bottom: 20px;
        text-transform: uppercase;
    }

    .loading-content-wrapper p {
        font-size: 1rem;
        opacity: 0.7;
        font-weight: 300;
        letter-spacing: 0.15em;
        min-height: 1.5em;
        transition: opacity 0.3s;
    }

    /* ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ãƒãƒ¼ï¼ˆæ–°ãƒ‡ã‚¶ã‚¤ãƒ³ã«åˆã‚ã›ãŸã‚·ãƒ³ãƒ—ãƒ«ç‰ˆï¼‰ */
    .loading-bar-container {
        width: 240px;
        height: 2px;
        background: rgba(26, 42, 58, 0.1);
        margin: 40px auto 0;
        border-radius: 2px;
        overflow: hidden;
    }

    .loading-bar-progress {
        width: 0%;
        height: 100%;
        background: #1a2a3a;
        animation: loadingProgress 2s infinite ease-in-out;
    }

    @keyframes loadingProgress {
        0% {
            width: 0%;
            transform: translateX(-100%);
        }

        50% {
            width: 70%;
            transform: translateX(0);
        }

        100% {
            width: 100%;
            transform: translateX(100%);
        }
    }
</style>

<div id="loadingOverlay">
    <div class="loading-content-wrapper">
        <h1>Grouping...</h1>
        <p id="loadingMessage">Initializing process</p>
        <div class="loading-bar-container">
            <div class="loading-bar-progress"></div>
        </div>
    </div>
    <canvas id="loadingCanvas"></canvas>
</div>

<script>
    (function () {
        // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒªã‚¹ãƒˆï¼ˆå…ƒã®ã‚³ãƒ¼ãƒ‰ã‚ˆã‚Šå¼•ãç¶™ãï¼‰
        const loadingMessages = [
            'é‡è¤‡ãƒšã‚¢ã‚’æœ€å°åŒ–ã—ã¦ã„ã¾ã™',
            'å·¥å…·ä¿‚ã‚’å„ã‚°ãƒ«ãƒ¼ãƒ—ã«é…ç½®ä¸­...',
            'ã‚°ãƒ«ãƒ¼ãƒ—ãƒãƒ©ãƒ³ã‚¹ã‚’èª¿æ•´ä¸­...',
            'å­¦å¹´ãƒ»æ€§åˆ¥ã‚’è€ƒæ…®ã—ãŸæœ€é©è§£ã‚’æ¢ç´¢ä¸­...',
            'ãƒ©ãƒ³ãƒ€ãƒ ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã§å±€æ‰€è§£ã‚’å›é¿ä¸­...',
            'æœ€é©ãªçµ„ã¿åˆã‚ã›ã‚’æ¤œè¨¼ä¸­...',
            'ğŸš´ ãƒãƒ£ãƒªéƒ¨ã®ãŸã‚ã«å…¨åŠ›è¨ˆç®—ä¸­!',
            'ãƒšã‚¢å±¥æ­´ã‚’ãƒã‚§ãƒƒã‚¯ä¸­...',
            'ã‚‚ã†å°‘ã—ã ã‘ãŠå¾…ã¡ãã ã•ã„...',
            'äº¤æ›æ”¹å–„ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ å®Ÿè¡Œä¸­...'
        ];

        let canvas, ctx, W, H;
        let rays = [];
        const mouse = { x: -9999, y: -9999, radius: 100 };
        let time = 0;
        let animationId = null;
        let messageInterval = null;

        // â”€â”€ Ray Class â”€â”€
        class Ray {
            constructor(index, total) {
                this.baseX = W / 2 + (Math.random() - 0.5) * 20;
                this.baseY = H + 20;

                const angleStep = Math.PI / total;
                const variance = (Math.random() - 0.5) * 0.2;
                this.angle = Math.PI + (index / total) * Math.PI + variance;

                const rand = Math.random();
                if (rand < 0.3) {
                    this.layer = 2;
                    this.length = H * 0.15 + Math.random() * H * 0.25;
                    this.lineWidth = 1.5 + Math.random() * 0.5;
                    this.alpha = 0.8 + Math.random() * 0.2;
                    this.stiffness = 0.03 + Math.random() * 0.02;
                } else if (rand < 0.7) {
                    this.layer = 1;
                    this.length = H * 0.4 + Math.random() * H * 0.3;
                    this.lineWidth = 1.0 + Math.random() * 0.3;
                    this.alpha = 0.5 + Math.random() * 0.3;
                    this.stiffness = 0.02 + Math.random() * 0.02;
                } else {
                    this.layer = 0;
                    this.length = H * 0.7 + Math.random() * H * 0.3;
                    this.lineWidth = 0.5 + Math.random() * 0.4;
                    this.alpha = 0.3 + Math.random() * 0.3;
                    this.stiffness = 0.01 + Math.random() * 0.02;
                }

                this.targetTipX = this.baseX + Math.cos(this.angle) * this.length;
                this.targetTipY = this.baseY + Math.sin(this.angle) * this.length;

                this.currentTipX = this.targetTipX;
                this.currentTipY = this.targetTipY;

                this.vx = 0;
                this.vy = 0;
                this.damping = 0.85;

                this.hasDot = true;
                this.dotSize = this.lineWidth * (1.2 + Math.random() * 0.5);

                const baseColor = this.layer === 2 ? 100 : this.layer === 1 ? 150 : 200;
                this.colorStr = `${10 + Math.random() * 30}, ${baseColor + Math.random() * 50}, ${200 + Math.random() * 55}`;
            }

            update() {
                const breathe = Math.sin(time * 0.5 + this.targetTipX * 0.01) * 10;
                const targetX = this.targetTipX + breathe * Math.cos(this.angle);
                const targetY = this.targetTipY + breathe * Math.sin(this.angle);

                const dx = mouse.x - this.currentTipX;
                const dy = mouse.y - this.currentTipY;
                const dist = Math.sqrt(dx * dx + dy * dy);

                let mfx = 0, mfy = 0;
                if (dist < mouse.radius && dist > 0) {
                    const force = (1 - dist / mouse.radius) * 60;
                    mfx = -(dx / dist) * force;
                    mfy = -(dy / dist) * force;
                }

                const ax = (targetX - this.currentTipX) * this.stiffness + mfx * 0.2;
                const ay = (targetY - this.currentTipY) * this.stiffness + mfy * 0.2;

                this.vx += ax;
                this.vy += ay;
                this.vx *= this.damping;
                this.vy *= this.damping;

                this.currentTipX += this.vx;
                this.currentTipY += this.vy;
            }

            draw() {
                ctx.beginPath();
                ctx.moveTo(this.baseX, this.baseY);
                ctx.lineTo(this.currentTipX, this.currentTipY);

                ctx.strokeStyle = `rgba(${this.colorStr}, ${this.alpha})`;
                ctx.lineWidth = this.lineWidth;
                ctx.stroke();

                if (this.hasDot) {
                    ctx.beginPath();
                    ctx.arc(this.currentTipX, this.currentTipY, this.dotSize, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(${this.colorStr}, ${Math.min(1, this.alpha + 0.2)})`;
                    ctx.fill();
                }
            }
        }

        function initScene() {
            rays = [];
            const count = W < 600 ? 300 : 800;
            for (let i = 0; i < count; i++) {
                rays.push(new Ray(i, count));
            }
        }

        function animate() {
            time += 0.02;
            ctx.clearRect(0, 0, W, H);
            rays.forEach(r => {
                r.update();
                r.draw();
            });
            animationId = requestAnimationFrame(animate);
        }

        function resize() {
            if (!canvas) return;
            W = canvas.width = window.innerWidth;
            H = canvas.height = window.innerHeight;
            initScene();
        }

        // å¤–éƒ¨ã‹ã‚‰å‘¼ã³å‡ºã›ã‚‹é–¢æ•°ã¨ã—ã¦å®šç¾©
        window.showLoading = function () {
            const overlay = document.getElementById('loadingOverlay');
            overlay.classList.add('visible');

            canvas = document.getElementById('loadingCanvas');
            if (canvas) {
                ctx = canvas.getContext('2d');
                resize();
                window.addEventListener('resize', resize);
                window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
                window.addEventListener('touchmove', e => { mouse.x = e.touches[0].clientX; mouse.y = e.touches[0].clientY; });

                if (!animationId) animate();
            }

            const msgEl = document.getElementById('loadingMessage');
            let msgIdx = 0;
            msgEl.textContent = loadingMessages[0];

            if (messageInterval) clearInterval(messageInterval);
            messageInterval = setInterval(() => {
                msgEl.style.opacity = '0';
                setTimeout(() => {
                    msgIdx = (msgIdx + 1) % loadingMessages.length;
                    msgEl.textContent = loadingMessages[msgIdx];
                    msgEl.style.opacity = '1';
                }, 300);
            }, 2500);
        };
    })();
</script>